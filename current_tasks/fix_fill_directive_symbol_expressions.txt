Fix x86 assembler: .fill directive with symbol/label expressions in repeat count

The .fill directive fails when the repeat count is a symbolic expression like:
  .fill 0b + (8 * (1 + 1)) - ., 1, 0xcc
  .fill early_idt_handler_array + 1*(9 + (4*1)) - ., 1, 0xcc

The assembler's parse_integer_expr only handles numeric constants, not symbol
references or the current position (.). The .skip directive already has a
deferred expression path (SkipExpr) that evaluates after all labels are known.

Fix: When .fill repeat can't be parsed as a constant AND size=1, convert to
an equivalent SkipExpr(repeat_expr, fill_byte) which uses the existing deferred
expression infrastructure.

This fixes x86 standalone kernel build failures in entry_64.o and head_64.o.

Started: 2026-02-05
