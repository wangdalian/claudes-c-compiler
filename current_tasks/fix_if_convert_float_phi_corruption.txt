Fix if-convert pass corrupting float phi nodes in mixed int/float diamonds
==========================================================================

Problem: The if_convert pass partially converts diamond patterns when the merge
block contains both integer and float phi nodes. It converts integer phis to
Select instructions, removes the arm blocks, but leaves float phi nodes pointing
to the now-removed blocks. This causes the float variables to get zero values
instead of their correct pre-branch values.

Reproducer:
  long ia = 1, ib = 2, ic = 4;
  double da = 1.0, db = 2.0, dc = 4.0;
  da = 9.0; db = 6.0; // after computation
  if (db > da) {
    da = dc * 5.0; dc = db - da;  // modifies doubles
  } else {
    ia = ib + ic; ...  // modifies ints only
  }
  // After merge: da + db + dc should be 19, but gets 6 because da=0, dc=0

Fix:
1. Don't convert diamonds that have unconvertible (float/long double) phi nodes
2. Support float Select in if_convert and all three backends (x86 cmov via GPR,
   ARM csel, RISC-V conditional move pattern)

Status: In progress
