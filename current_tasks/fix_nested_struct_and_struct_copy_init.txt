Task: Fix nested struct member access via pointer, struct copy-init, and array-of-pointers element type

Bug 1: Nested struct member access via pointer (p->in.val) segfaults
Problem: When accessing p->in.val where "in" is an embedded struct (not a pointer),
get_struct_base_addr had no handler for PointerMemberAccess. It fell through to the
catch-all which called lower_expr, which loaded the struct field data as if it were
a scalar value, then used that garbage as a pointer address.
Fix: Added PointerMemberAccess handler to get_struct_base_addr in structs.rs that:
  - Loads the pointer (p)
  - Computes field offset (for "in")
  - Returns the resulting address (without loading)
Also added PointerMemberAccess to get_layout_for_expr to resolve the embedded struct's
layout for subsequent field access.

Bug 2: Struct copy-initialization (struct Point b = a) doesn't copy
Problem: In lower_local_decl, when the initializer is an Expr and is_struct is true,
the code had a TODO comment and did nothing. The struct was left zero-initialized.
Fix: Added struct copy-init path that calls get_struct_base_addr to get the source
struct address, then emits Memcpy from source to the destination alloca.

Bug 3: Array-of-pointers (int *arr[3]) uses wrong element type for stores
Problem: compute_decl_info correctly returned (size=24, elem_size=8, is_array=true,
is_pointer=false) for array-of-pointers, but var_ty was set from base_ty (I32) since
is_pointer was false. Stores to arr[i] used movl (4 bytes) instead of movq (8 bytes),
truncating pointer values.
Fix: Added is_array_of_pointers detection (Pointer before Array in derived declarators)
to set var_ty = Ptr when elements are pointers.

Status: Complete
