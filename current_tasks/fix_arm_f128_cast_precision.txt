Task: Fix ARM F128 cast precision loss (integer/float -> long double)

Status: in_progress

Problem:
On AArch64, when casting integer types (i64) or float types to long double
(F128 / IEEE quad precision), the emit_cast method in the ARM backend:
1. Correctly calls __floatditf/__floatunditf to convert to f128 in Q0
2. INCORRECTLY truncates to f64 via __trunctfdf2
3. Stores only the 8-byte f64 approximation
4. Later reconstructs via __extenddftf2 (losing precision)

This causes values like LLONG_MAX (9223372036854775807) to be rounded to
2^63 when converted to long double, since the double intermediate cannot
represent the full precision.

Fix:
Store the full 16-byte f128 result (Q0) directly to the dest slot after
the __floatditf/__floatunditf/__extendsftf2/__extenddftf2 call, then
track it with track_f128_self(). Produce the f64 approximation only for
register data flow (same pattern as emit_f128_binop_softfloat_full).

Files to modify:
- src/backend/arm/codegen/codegen.rs (emit_cast method, lines ~3410-3483)

Affected tests:
- compiler_suite_0093_0052: i64 -> long double LLONG_MAX conversion
- compiler_suite_0093_0053: u64 -> long double conversion
- Potentially other F128 precision tests
