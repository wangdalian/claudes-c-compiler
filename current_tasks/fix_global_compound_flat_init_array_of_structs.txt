Fix global compound flat init of array-of-structs with pointer members
=====================================================================
Date: 2026-01-30
Status: in_progress

Problem:
When a global struct contains an array-of-structs field and the initializer
uses flat (brace-less) expressions, and the inner struct type contains pointer
members, the compiler only consumes `arr_size` items (the number of array
elements) instead of `arr_size * num_fields` items (the total number of scalar
initializer values needed).

This causes:
1. Items to be silently dropped from the initializer
2. Garbled struct layout where scalars are placed in pointer-sized slots
3. Segfaults at runtime when uninitialized pointers are dereferenced

Root cause locations:
- src/ir/lowering/global_init_compound_struct.rs (flat init collection loop)
- src/ir/lowering/global_init_compound.rs (emit_compound_flat_array_init)

The local init path handles this correctly by recursively delegating to
emit_struct_init for each array element. The global compound path needs
similar recursive handling.

Example:
  struct P { int *p; int val; };
  struct Q { struct P items[3]; int count; };
  struct Q q = { &g1, 1, &g2, 2, &g3, 3, 3 };  // flat init - BUG
