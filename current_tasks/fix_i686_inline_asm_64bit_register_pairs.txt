Task: Fix i686 inline asm 64-bit register pair handling
Status: completed

Problem: On i686, inline asm constraints like "+r" with 64-bit (unsigned long long)
values only allocate a single 32-bit register, causing the high 32 bits to be lost.
This breaks xxhash's XXH_COMPILER_GUARD macro: __asm__("" : "+r" (val))

Root cause (two bugs):
1. No register pair allocation: The shared inline asm framework only allocated a
   single GP register for 64-bit operands on i686. Fixed by adding needs_register_pair()
   trait method and allocating a second register (reg_hi) for I64/U64 types.

2. Missing wide_values tracking: After mem2reg promoted the asm output alloca to a
   fresh SSA value, the stack layout code did not add it to wide_values. This caused
   Copy instructions referencing the asm output to only copy the low 32 bits (zeroing
   the high 32 bits). Fixed by marking 64-bit asm output values as wide in stack_layout.rs.

Files changed:
- src/backend/inline_asm.rs: Added reg_hi field, needs_register_pair() trait method,
  register pair allocation in assign_scratch_registers()
- src/backend/i686/codegen/asm_emitter.rs: Implemented needs_register_pair(),
  updated load_input_to_reg, preload_readwrite_output, store_output_from_reg for pairs
- src/backend/stack_layout.rs: Added wide_values tracking for 64-bit asm output values
- tests/i686-inline-asm-64bit-register-pair/: Regression test
- ideas/new_projects.txt: Updated xxhash status

Verification: xxhash passes all 49,948 tests on all 4 architectures (x86, i686, arm, riscv).
Full test suite: 48/48 projects pass, no regressions.
