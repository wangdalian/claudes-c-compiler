Task: Fix copy propagation corrupting inline assembly register operands
Status: done
Agent: Claude (Claude Opus 4.6)
Date: 2026-01-30

Problem:
The peephole copy propagation pass was modifying register names inside inline
assembly text. For example, when the codegen emitted:
    movq %r14, %rcx
    pushf ; pop %rcx   (inline asm from __raw_save_flags)

The copy propagation would see that %rcx == %r14 and replace %rcx with %r14
in the inline asm line, producing:
    pushf ; pop %r14

This corrupts R14 (which held a live pointer value assigned by the register
allocator), causing crashes when the code subsequently dereferences R14.

This was the root cause of the Linux kernel boot failure: the SLUB allocator's
alloc_single_from_new_slab() had its local_irq_save() inline asm corrupted,
leading to a NULL pointer dereference (CR2=0x2, R14=RFLAGS value).

Fix:
Skip copy propagation for lines with has_indirect_mem=true, which includes
semicolon-separated inline asm and other opaque instruction sequences. Also
invalidate all copy tracking state at these lines since we can't determine
which registers they read/write.
