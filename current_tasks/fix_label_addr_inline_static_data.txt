Fix: prevent inlining functions with LabelAddr when they have static local data with label refs

Bug: When a static inline function contains &&label (label address) stored in a static
local array (e.g., `static void *b[] = { &&addr }`), the label BlockId is emitted into
the global data section as `.quad .LN`. When the function gets inlined, the body's block
IDs are remapped to new IDs, but the static data's string reference (`.quad .L3`) is NOT
updated, leaving a dangling reference to a non-existent label.

This causes linker errors: "undefined reference to `.L3'"

Test case: gcc_torture_20071220_2 (static void *b[] = {&&addr} inside static inline bar())

Fix: Add LabelAddr to the list of instructions that prevent a function from being inlined.
This is the simplest correct fix since static data label references are strings (not BlockIds)
and are not tracked through the inlining remapping system.

Status: in_progress
