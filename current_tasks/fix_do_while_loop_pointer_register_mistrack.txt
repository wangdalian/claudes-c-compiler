Fix do-while loop pointer register mistrack

Bug: When a pointer variable is incremented in a do-while loop and then used
after the loop exits, the compiler uses a different register (r11, which was
never assigned) instead of the register holding the updated pointer (r10).

Example:
  const char *in = ...;
  do { in++; } while (tbl[(int)*in]);
  return in - start;  // uses wrong register for 'in'

Root cause: The peephole optimizer's eliminate_loop_trampolines pass performed
register coalescing (NOPping movq %r10, %r11 and rewriting addq to target r10
directly) without checking that r11 (src_fam) was still live on the fall-through
path after the loop. The fall-through code read r11 expecting the incremented
pointer but got a stale/uninitialized value.

Fix: Extended the fall-through safety analysis to check both dst_fam AND src_fam
for liveness. Also fixed the CondJmp case to properly bail out (was breaking with
fall_through_safe=true, contradicting the conservative intent).

Affects: lacc (all 269 x86 tests failed, now 155 pass), likely other projects
Status: complete
