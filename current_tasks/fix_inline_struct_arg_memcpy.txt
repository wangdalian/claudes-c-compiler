Task: fix_inline_struct_arg_memcpy
Status: completed
Description: Fix inlining pass miscompilation where small struct arguments from non-FunctionCall
expressions (e.g., statement expressions returning struct-returning function calls) are treated
as pointers instead of packed data values, causing the Memcpy in the inlined code to use the
struct data as a source address instead of creating a spill alloca.

Also fixed struct_value_size() not handling StmtExpr, which caused try_small_struct_return()
to skip the small struct return path. This made functions returning struct dereferences inside
statement expressions (like the kernel's ptep_get using READ_ONCE(*ptep)) return the pointer
instead of loading the value through it.

Root cause: Two related issues:
1. In expr_calls.rs lower_call_arguments(), the spill of packed struct return values
to allocas only fired for Expr::FunctionCall arguments. Extended to handle all expressions
that produce packed struct data via expr_produces_packed_struct_data().
2. In expr_types.rs struct_value_size(), StmtExpr was not handled, causing it to return None.
This made try_small_struct_return() bail out, falling through to the default scalar return
path which returned the struct address instead of loading the struct value.

Fix: Added StmtExpr handling to struct_value_size() and expr_produces_packed_struct_data()
to recurse into the last expression of the compound statement.
