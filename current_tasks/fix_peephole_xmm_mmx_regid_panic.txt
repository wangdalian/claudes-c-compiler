Task: Fix peephole pass panics when encountering XMM/MMX register IDs

Status: in_progress

Problem:
The peephole store forwarding pass panics with index-out-of-bounds when assembly
lines contain XMM/MMX register stores/loads to the stack (e.g., movq %xmm0, -8(%rbp)).

Root causes:
1. classify_line() creates StoreRbp/LoadRbp with XMM/MMX register family IDs (16-39),
   and also computes `1u16 << reg` which overflows for reg >= 16.
2. reg_id_to_name() indexes REG_NAMES[row][id] where REG_NAMES is [16], panicking for id >= 16.
3. invalidate_reg_flat() indexes reg_offsets[reg_id] where reg_offsets is [SmallVec; 16],
   panicking for reg_id >= 16 or REG_NONE (255).
4. SetCC handler calls invalidate_reg_flat without guarding against REG_NONE.

Fix:
- In classify_line, only create StoreRbp/LoadRbp for GP registers (reg <= 15).
  XMM/MMX stack accesses fall through to Other classification.
- Guard reg_id_to_name calls in store forwarding with load_reg <= REG_GP_MAX check.
- Guard SetCC invalidate_reg_flat call with reg != REG_NONE && reg <= REG_GP_MAX.
- Fix 1u16 << reg overflow for Pop classification with non-GP register.

Affects: 4+ test cases (asm-mmx-movq, asm-movq-xmm, asm-xor-zero)
