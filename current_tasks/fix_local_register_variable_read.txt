Task: Fix local register variable reads (e.g., register ... __asm__("tp"))

Problem:
Local register variables declared with __asm__("regname") inside functions
return 0 instead of reading the actual hardware register value. Global register
variables work correctly.

Example:
  unsigned long read_tp(void) {
      register unsigned long tp __asm__("tp");
      return tp;  // Returns 0 instead of actual tp register value
  }

Root cause:
In lower_identifier() (src/ir/lowering/expr.rs), the local variable path
(lines ~244-271) never checks info.asm_register. It always loads from the
alloca, which is never initialized with the hardware register value.
The global variable path (lines ~284-288) correctly checks ginfo.asm_register
and calls read_global_register().

Impact:
This breaks the Linux kernel on RISC-V, where kernel/sched/core.c uses
local register variables to access the tp register (for per-cpu data and
the current task pointer). The kernel hangs during early boot because
scheduler functions read 0 instead of the actual register values.

Fix:
Add asm_register check in lower_identifier() local path, similar to the
global path. When asm_register is Some, call read_global_register() instead
of loading from the alloca.

Status: in_progress
