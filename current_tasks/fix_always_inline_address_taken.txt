Task: Fix always_inline functions being removed when their address is taken

Problem:
  When a static __always_inline function has its address taken (used as a
  function pointer), the compiler still removes the standalone body during
  dead code elimination. This causes linker errors because the function
  pointer references an undefined symbol.

  Specific case: kernel/module/tree_lookup.c has static __always_inline functions
  mod_tree_less() and mod_tree_comp() whose addresses are stored in the
  mod_tree_ops struct. The compiler removes their standalone bodies, causing:
  "undefined reference to `mod_tree_less'" and "undefined reference to `mod_tree_comp'"

Fix:
  In the dead code elimination pass (passes/mod.rs), check whether a static
  always_inline function's address is taken anywhere in the module before
  removing it. If the address is taken, keep the standalone body so it can
  be linked.

Status: in_progress
