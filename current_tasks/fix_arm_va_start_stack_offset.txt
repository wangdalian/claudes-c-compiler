Fix ARM64 va_start __stack offset calculation for variadic functions

Problem:
When an ARM64 variadic function has more than 8 float/double named parameters,
the overflow parameters go on the stack. But va_start's __stack pointer only
accounted for GP register overflow (named_stack_gp_count), not FP register
overflow or other stack-passed named args (structs, i128, f128).

This caused va_arg to read variadic arguments from the wrong stack location,
resulting in corrupt float/double values (e.g., getting 0 or raw float bits
instead of the correct promoted double value).

Fix:
Replace va_named_stack_gp_count (GP-only overflow count) with va_named_stack_bytes
(total bytes of ALL named stack-overflow args), computed via classify_params which
correctly handles all parameter types (int, float, struct, i128, f128).
