Compile Speed Improvements
===========================
Priority: HIGH

Profiled on kernel/softirq.c (callgrind, 2.31B instructions).

Remaining bottlenecks:

1. EXTERNAL ASSEMBLER
   The compiler shells out to gcc/as for assembling text assembly into
   object files. Process spawn overhead matters for parallel kernel builds.
   Fix: Native assembler + ELF writer (see native_elf_writer.txt).
   Expected improvement: eliminates fork/exec per compilation unit.

2. ALLOCATION OVERHEAD (~17.5% of total)
   malloc/free/realloc/memcpy dominate the profile (5.5% _int_malloc,
   5% memcpy, 4.5% _int_free, 3% malloc, 1.7% free, etc.).
   Partially fixed: build_cfg uses FlatAdj CSR format, CFG/dominator
   analysis shared via CfgAnalysis. Pipeline clone eliminated.
   Further: arena/bump allocators, string interning, reuse Vec buffers.

3. PREPROCESSOR (~17.6% of total)
   preprocess_source is the single hottest function. Macro expansion
   (expand_text) is 5.8%, process_directive is 3.5%.
   Partially fixed: FxHashSet reuse, include caching, Cow<str>.
   Further: byte-level processing, reduced String allocations.

4. STRING INTERNING (potential ~5% improvement)
   Every identifier token allocates a heap String. Same function/type
   names are re-allocated at each compiler stage (lexer -> AST -> IR).
   Fix: String interning with u32 symbol IDs would eliminate most of
   the per-identifier allocation overhead.

5. LEXER (~4.2% of total)
   Lexer::tokenize is the 2nd hottest ccc function. Dominated by
   identifier scanning and keyword lookup (~70-arm match).
   Fix: Perfect hash for keywords, reduced from_utf8 overhead.

The native assembler (item 1) and string interning (item 4) are the
highest-impact remaining changes.
