Fix remaining i686 project failures
=====================================
Date: 2026-01-28 (updated after bitfield I32 ops fix)

Current status:
- Unit tests: 99.9% pass - up from 99.7%
- Projects passing: 9/15 (zlib, lua, libpng, jq, libjpeg, libuv, redis, musl, tcc*)
  * tcc build succeeds; test suite fails due to missing i686 CRT/headers (same as GCC)
- Projects failing: libsodium, mquickjs, sqlite, mbedtls, postgres
- Projects fixed this round: libffi (was crashing due to __CET__ mismatch)

Fixed in latest round (bitfield I32 ops fix):
- Bitfield extract/store operations used hardcoded IrType::I64 for all shift/mask ops
  - Root cause: truncate_to_bitfield_value, store_bitfield, store_bitfield_split,
    extract_bitfield, extract_bitfield_from_addr in src/ir/lowering/expr_assign.rs
    all used IrType::I64 and 64-bit shift amounts unconditionally.
  - On i686, this generated shrdl/shldl (64-bit shift pairs) that read eax:edx,
    but loaded 32-bit values only populated eax, leaving edx uninitialized.
  - Fix: Use widened_op_type(storage_ty) → I32 on i686, I64 on 64-bit targets.
  - Fixes bitfield corruption in structs like mquickjs JSString (uint32_t with
    len:25, is_ascii:1, etc. bitfields).
  - No regressions: x86-64 99.8%, ARM 99.7%, RISC-V 100.0%, i686 99.7%
  - Note: mquickjs still fails due to separate ROM table mismatch (see below)

Previously fixed (LogicalNot 64-bit fix):
- LogicalNot (!) on 64-bit values was truncating to 32 bits on i686
  - Root cause: UnaryOp::LogicalNot in src/ir/lowering/expr_ops.rs used
    target_int_ir_type() (I32 on i686) as the comparison type for ALL values,
    including I64/U64. Values like 0x100000000ULL were incorrectly treated as zero.
  - Fix: Use inner expression's type for comparison when it is a wide integer
    (I64/U64) wider than target int. Float types excluded since
    mask_float_sign_for_truthiness already reduces them to I32 booleans.
  - Fixes comk3114 test (64-bit shift loop with `!i` condition)
  - libjpeg now 2/2 (was 1/2 before)
  - i686 unit test pass rate improved from ~99.2% to 99.7%
  - No regressions on x86-64 (99.9%), ARM (99.6%), RISC-V (99.9%)

Fixed (Redis i686 fix):
- PIC global address: emit_global_addr used GOT-relative %ebx addressing without
  setting up %ebx; switched to absolute addressing since we link with -no-pie
- mem2reg constant narrowing: I64 constants stored into 32-bit allocas caused
  phi-elimination to use 64-bit copies, leaving upper 32 bits uninitialized
- Added IrConst::narrowed_to() to narrow constants to match alloca type in mem2reg
- Redis: now fully passes on i686 (build + SET/GET + cli)

Previously fixed (Copy I64 const wide marking fix):
- tcc BUILD now succeeds (was failing in alloca86_64.S assembly)
- libjpeg fully passes (was "Bogus virtual array access")

Previously fixed (inline asm typed register load fix):
- libsodium now BUILDS (was failing with "operand size mismatch for `movzw'")

Fixed (inline asm "g" constraint register conflict):
- musl: All 6/6 tests now pass on i686 (was 3/6)
  - Root cause: On i686 with only 6 GP registers, __syscall6() uses all 6 via
    specific constraints ("a", "b", "c", "d", "S", "D"). The 7th operand with "g"
    constraint was assigned eax (conflicting with "a"), overwriting the syscall
    number. mmap2 (0xc0) became restart_syscall (0), causing malloc to fail.
  - Fix: When assign_scratch_reg exhausts all GP registers and the constraint has
    a memory alternative (like "g"), fall back to AsmOperandKind::Memory and emit
    the value's stack slot offset directly (e.g., -8(%ebp)) as the operand.
  - This fixed malloc, io (tmpfile), and environ (setenv/getenv) which all depend
    on mmap2 via musl's malloc.

Known remaining issues:

1. sqlite: 2/622 tests pass (was 0/622) -- READONLY_DBMOVED bug
   - Root cause FOUND: After inlining fileHasMoved() into unixFileControl(),
     the codegen reads buf.st_ino from the WRONG stack offset.
   - stat buffer allocated at -120(%ebp), st_ino at offset 12 -> should be -108(%ebp)
   - But codegen reads from -32(%ebp) = buf + 88 = past end of buffer
   - This reads stale/uninitialized data, causing fileHasMoved() to return true,
     which makes sqlite think the database file was moved/renamed (SQLITE_READONLY_DBMOVED)
   - Workaround: journal_mode=OFF or :memory: databases work correctly
   - The struct layout is correct (verified offset 12 for st_ino on both CCC and GCC)
   - The standalone function generates correct code (-92(%ebp) for buf at -104)
   - The bug is specific to the INLINED version in the large unixFileControl() function
   - This is likely a codegen bug in stack slot assignment or value remapping after inlining
   - Investigation needed in: src/passes/inline.rs (value remapping) or
     src/backend/i686/codegen/ (stack frame layout for large functions)

2. mquickjs: SIGSEGV in all 5 tests
   - Crashes in js_string_compare during JS parsing
   - Root cause FOUND: TWO issues:
     a) Bitfield ops used I64 on i686 → FIXED (bitfield I32 ops fix above)
     b) ROM table mismatch: verify_mquickjs.py builds host tools with x86_64 GCC,
        generating js_stdlib_table as uint64_t[] (JSValue=uint64_t on x86_64).
        But on i686 target, JSValue=uint32_t, so the ROM table entries are wrong size.
        The verify script doesn't pass CONFIG_X86_32=y for i686 builds.
        This is a BUILD SYSTEM issue in /verify/verify_mquickjs.py (read-only).
        NOT a compiler bug — mquickjs needs cross-compilation-aware host tool build.

3. libsodium: Build succeeds, 0/7 tests pass
   - Mix of timeouts (infinite loops) and SIGSEGV crashes
   - init/hash_sha256/secretbox timeout; random/sign/box SIGSEGV
   - Heavy use of 64-bit crypto operations may expose additional codegen bugs

4. mbedtls: Build fails (__builtin_ia32_pshufd not implemented)
   - Needs SSE2 intrinsic: _mm_shuffle_epi32 -> __builtin_ia32_pshufd
   - Used in AES-NI key schedule (aesni_set_rk_128/192/256)

5. libffi: FIXED - all 6/6 tests pass (including closures)
   - Root cause: __CET__ was defined for i686 but i686-linux-gnu-gcc -m32
     (used for assembling .S files) does NOT define __CET__. This caused a
     mismatch where C code expected ENDBR_PRESENT (44-byte trampolines) but
     assembly produced non-ENDBR trampolines (40 bytes).
   - Fix: undefine __CET__ for i686 target in predefined_macros.rs

6. postgres: Build fails - linker error (R_386_GOTOFF relocation / shared lib issue)
   - dict_snowball.so link fails
   - May be related to PIC/shared library handling on i686

7. tcc: Build succeeds, 1/78 tests pass
   - Tests fail because CCC-compiled TCC can't find crt1.o
   - System configuration issue (same with GCC), not a compiler bug

Priority investigation targets:
- sqlite inlining bug: This is the highest-value fix (622 tests).
  The root cause is identified; need to fix codegen or inline pass.
- mquickjs crashes: May share root cause with sqlite inlining bug.
- libsodium timeouts: May be related to remaining 64-bit operation bugs.
- mbedtls __builtin_ia32_pshufd: SSE2 intrinsic implementation.

Techniques:
- Compare i686 assembly output against i686-linux-gnu-gcc for suspect functions
- Use GDB to trace execution and find divergence points
- strace to check syscall behavior for musl failures
- Hybrid builds (CCC sqlite3.c + GCC harness, or vice versa) to isolate bugs
