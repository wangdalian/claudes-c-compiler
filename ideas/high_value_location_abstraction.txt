HIGH PRIORITY: Introduce ValueLocation abstraction for eventual register allocation

STATUS: Phase 1 (RegCache) completed. Next steps below.

Completed:
- Added RegCache struct to state.rs tracking accumulator register contents across
  all 3 backends (x86/ARM/RISC-V). Skips redundant loads when the value is already
  in the accumulator register (rax/x0/t0).
- Conservative cache strategy: only preserved across Copy instructions; all other
  instructions invalidate the cache after execution. Block boundaries also invalidate.
- Test results after RegCache: x86 2921/2991 (97.7%), ARM 2805/2869 (97.8%),
  RISC-V 2836/2861 (99.1%) -- no meaningful regressions from baseline.

Remaining work:
1. Introduce a ValueLocation enum:
     enum ValueLocation {
         Stack(StackSlot),
         Register(PhysReg),  // for future use
     }
2. Change value_locations to HashMap<u32, ValueLocation>
3. Initially, all values still get ValueLocation::Stack -- behavior unchanged
4. Update emit_load_operand / emit_store_result to dispatch on ValueLocation
5. Extend RegCache to also track the secondary register (rcx/x1/t1)
6. Add invalidate_value() for targeted invalidation on stores
7. Expand the set of instructions that preserve the cache (especially pure
   operations like BinOp, UnaryOp, Cast where the result is stored to acc)

Key files:
- src/backend/state.rs (CodegenState, StackSlot, RegCache, RegCacheEntry)
- src/backend/generation.rs (cache invalidation strategy in generate_instruction)
- src/backend/x86/codegen/codegen.rs (operand_to_rax, store_rax_to, + 6 invalidation sites)
- src/backend/arm/codegen/codegen.rs (operand_to_x0, store_x0_to)
- src/backend/riscv/codegen/codegen.rs (operand_to_t0, store_t0_to)

Relationship to ideas/register_allocator.txt:
That idea describes the full register allocator. This idea is the prerequisite
abstraction step. RegCache is the first concrete step toward it.
