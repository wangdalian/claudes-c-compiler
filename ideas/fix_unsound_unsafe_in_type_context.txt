Fix unsound unsafe raw-pointer mutation in TypeContext

There are THREE instances of unsound unsafe code in type_context.rs that cast
away const to mutate through shared references (&self):

1. insert_struct_layout_from_ref (line ~204):
   Mutates struct_layouts via raw pointer cast.

2. insert_struct_layout_scoped_from_ref (lines ~338-351):
   Mutates both struct_layouts and scope_stack via raw pointer casts.

3. invalidate_ctype_cache_scoped_from_ref (lines ~362-372):
   Mutates scope_stack via raw pointer cast.

All three use the pattern:
    let ptr = &self.field as *const T as *mut T;
    unsafe { (*ptr).method(...); }

This violates Rust's aliasing rules regardless of single-threaded context.
The struct already uses RefCell for ctype_cache and Cell for anon_ctype_counter,
showing the author knows the correct interior mutability patterns.

Fix:
- struct_layouts: FxHashMap -> RefCell<FxHashMap>
- scope_stack: Vec -> RefCell<Vec>

Key files:
- src/frontend/sema/type_context.rs (lines ~204, ~338-351, ~362-372)
- src/frontend/sema/sema.rs (calls insert_struct_layout_scoped_from_ref)
- src/frontend/sema/type_checker.rs (calls insert_struct_layout_scoped_from_ref)
- src/ir/lowering/types_ctype.rs (calls both _from_ref methods)

Priority: Medium-High (soundness issue, but single-threaded compiler so
unlikely to cause practical problems)
