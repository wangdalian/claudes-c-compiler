# Common

Shared data types and utilities used across frontend, IR, and backend.

## Modules

- **error.rs** - Structured diagnostic infrastructure. `Diagnostic` (severity, message, span, notes), `Severity` (Error/Warning/Note), `DiagnosticEngine` (collects and renders diagnostics with GCC-compatible format and source snippet display). The engine is threaded through the driver -> parser -> sema pipeline. Supports error/warning counting, source line rendering with caret underline, and follow-up notes.
- **types.rs** - `CType` (C language types), `IrType` (IR types: I8/I16/I32/I64/U*/Ptr/F32/F64), `StructLayout` (computed struct field offsets and sizes). `IrType` includes `.size()`, `.align()`, signedness queries, and type conversion. `CType` provides type query helpers: `is_function_pointer()`, `is_struct_or_union()`, `is_complex()`, `pointee()`, `array_element()`, `func_ptr_return_type(strict)`, and usual arithmetic conversions. `StructLayout` provides `resolve_init_field_idx()` for designated/positional initializer resolution and `has_pointer_fields()` for checking if any field recursively contains pointer/function types.
- **symbol_table.rs** - Scoped symbol table used by sema and lowering. Push/pop scope, insert/lookup symbols by name.
- **source.rs** - Source location tracking: `Span`, `SourceLocation`, `SourceManager` for mapping byte offsets back to file/line/column.
- **type_builder.rs** - `TypeConvertContext` trait with a default `resolve_type_spec_to_ctype` method that handles all 22 primitive C type mappings, pointers, arrays, and function pointers. Sema and lowering implement only 4 divergent methods (typedef, struct/union, enum, typeof), ensuring primitive type mapping can never silently diverge. Also provides shared `build_full_ctype` for converting declarator chains into `CType`.
- **const_arith.rs** - Low-level constant arithmetic primitives: integer and float binary operations (`eval_const_binop`, `eval_const_binop_float`, `eval_const_binop_i128`), unary operations (`negate_const`, `bitnot_const`), cast chain bit manipulation (`truncate_and_extend_bits`), and zero-expression detection (`is_zero_expr`).
- **const_eval.rs** - Shared constant expression evaluation functions extracted from the duplication between `sema::const_eval` and `lowering::const_eval`. Contains: `eval_literal` (all literal types), `eval_builtin_call` (14 __builtin_* functions), `promote_sub_int` (C11 integer promotion for unary ops), `irconst_to_bits` (IrConst to raw u64), and `eval_binop_with_types` (binary ops with C usual arithmetic conversions). Both sema and lowering delegate here, each providing only their type-system-specific context (CType vs IrType) for signedness/width resolution.
- **asm_constraints.rs** - Shared inline assembly constraint classification. Contains `constraint_is_immediate_only()` to identify constraints like "i" or "n" that only accept compile-time constants (no register or memory alternatives). Used by the inline pass (symbol resolution after inlining) and the backend (operand emission with $0 placeholders for unresolvable immediates).
- **long_double.rs** - Full-precision x87 80-bit extended precision support for long double. Provides `parse_long_double_to_x87_bytes` (decimal string to 16-byte x87 format), `x87_bytes_to_f128_bytes` (x87 to IEEE 754 quad precision for ARM64/RISC-V), `x87_bytes_to_{i64,u64,i128,u128}` (x87 to integer conversions), and full-precision arithmetic functions (`x87_add/sub/mul/div/rem/neg/cmp`) that use x87 FPU inline assembly on x86-64 hosts to compute with the full 64-bit mantissa. The arithmetic functions are used by constant folding to avoid precision loss when evaluating long double expressions at compile time. Uses a pure-Rust big-integer implementation for parsing with no external dependencies.
- **fx_hash.rs** - FxHash: a fast non-cryptographic hash function used for HashMap/HashSet throughout the compiler.

## Why Types are Split

`CType` represents the C language type system (struct tags, function pointer signatures, array dimensions). `IrType` is a simpler flat enumeration for the IR. The lowering phase converts `CType` â†’ `IrType` during code generation.
