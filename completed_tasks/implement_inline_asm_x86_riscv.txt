Task: Implement inline assembly support for x86 and RISC-V backends
Status: COMPLETED
Commit: c11544a

Problem:
The x86 and RISC-V backends had stub implementations for inline assembly that
only emitted a comment. This caused 253 x86 asm tests and 123 RISC-V asm tests
to fail (producing wrong results or assembler errors).

Solution:
Implemented full inline asm codegen for both backends, following the existing
ARM implementation pattern:

1. IR Enhancement (ir.rs, lowering/stmt.rs):
   - Added operand_types Vec<IrType> to InlineAsm IR instruction
   - Lowering now collects expression types for all operands including synthetic "+" inputs
   - operand_types enables type-based register size selection in backends

2. x86 Backend (x86/codegen/codegen.rs, +453 lines):
   - Register allocation: scratch pool (rcx, rdx, rsi, rdi, r8-r11)
   - Specific register constraints: "a"→rax, "d"→rdx, "c"→rcx
   - Template substitution with GCC-compatible numbering (skips synthetic "+" inputs)
   - Size modifiers: %k (32-bit eax), %w (16-bit ax), %b (8-bit al), %h (8-bit ah), %q (64-bit rax)
   - Type-based default sizing: I32→%k, I16→%w, I8→%b (fixes "register type mismatch" errors)
   - Tied operand deferred resolution ("0"/"1" constraints)
   - Read-write "+" constraint: pre-loads current value, stores back after asm

3. RISC-V Backend (riscv/codegen/codegen.rs, +295 lines):
   - Register allocation: scratch pool (t0-t6, a2-a7)
   - Specific register constraints: "a0"-"a7", "ra", "t0"-"t2"
   - Template substitution with GCC-compatible numbering
   - Tied operand deferred resolution
   - Read-write "+" constraint handling

4. Shared Infrastructure (codegen_shared.rs):
   - Updated emit_inline_asm trait signature to pass operand_types
   - ARM backend signature updated (unused, ARM already worked)

Key bugs fixed during implementation:
- GCC operand numbering: synthetic "+" inputs are hidden from %N numbering
- Register type mismatch: use operand types to determine default register size
- Tied operand allocation: defer until after scratch register assignment
- "rm" constraint: treat as register (not memory) when both are allowed
- "+" synthetic input position: placed at beginning of inputs list

Results (verified with full regression suite):
- x86:    71.2% → 77.7%  (+193 tests, 2130→2323 of 2991)
- ARM:    80.4% → 80.4%  (no change, no regressions)
- RISC-V: 74.2% → 77.0%  (+80 tests, 2124→2204 of 2861)

x86 asm tag:    0% → 73.9% (187/253 passing)
RISC-V asm tag: 0% → 74.8% (92/123 passing)

Remaining asm failures include: XMM register constraints (floating-point asm),
specific x86 assembly syntax edge cases, and some RISC-V-specific patterns.
